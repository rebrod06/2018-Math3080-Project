---
title: "MATH 3080 Lab Project 7"
author: "Erik Szylard Daenitz"
date: "February 22, 2018"
output:
  html_document:
    toc: TRUE
---

*Remember: I expect to see commentary either in the text, in the code with comments created using `#`, or (preferably) both! **Failing to do so may result in lost points!***

## Problem 1
REMINDER: Power is the probability of accepting the alternative hypothesis when it is true!

We can construct simulated power curves by the following procedures:

1) Make a function that:

- takes as parameters $n$, $\mu$ (as a vector), and $\sigma$ (as a vector)

- generates 3 normal samples of size 200 with $\mu=0$ and $\sigma=1$

- runs the analysis of variance test

- returns the p-value (HINT: `p.value=summary(res)[[1]][["Pr(>F)"]][1]`)

- Run this function 100 times. Compute the proportions of rejections ($\alpha = 0.05$).

```{r, tidy = TRUE}
set.seed(100000) # DON'T CHANGE THIS SEED!


# Function parameters are listed below
# m is a vector of three different mu values
# s is a vector of three sigmas as specified in the problem
# n is the number of random variables to test

power_sim = function(m, s, n){
  # create 200 normal samples for each mu and sigma
  sample_1 = rnorm(n, m[1], s[1])
  sample_2 = rnorm(n, m[2], s[2])
  sample_3 = rnorm(n, m[3], s[3])
  
  # stack data to form a list
  test_data = stack(list(r1 = sample_1, r2 = sample_2, r3 = sample_3))

  # check for homogeneity of data using barlett's test
  bartlett.test(test_data$values ~ test_data$ind, data = test_data)
  
  # perform a one way ANOVA test
  results <- aov(test_data$values ~ test_data$ind, data = test_data)

  # save p-value and return in variable p_val
  p_value = summary(results)[[1]][["Pr(>F)"]][1]
  return (p_value)
}
```

```{r, tidy = TRUE}
# We now run the function 100 times, calulate the proportion of rejections and output it

# Store mu and sigma values below as vectors
ml_1 = c(0,0,0)
sl_1 = c(1,1,1)

# run the function 100 times and save p-values in experiment_results
experiment_results = replicate(100, power_sim(ml_1, sl_1, 200))

#count number of p-values < .05 (when we reject H0)
rejections_count = sum(experiment_results < .05)

# calculate proportion of rejections to get probablity of type I error
p1 = rejections_count / length(experiment_results)
p1

print(paste("We see the proportion of p-values that lead to rejection of H0 is",p1,"."))
```

2) Now change the mean $\mu_1$ to be 0.1, run the ANOVA test 100 times, compute the proportion of rejections.

```{r, tidy = TRUE}
# We now update the mu and sigma values per specifications above
ml_2 = c(.1,0,0)
sl_2 = c(1,1,1)

# run function 100 times and save p-values in experiment_results
experiment_results2 = replicate(100, power_sim(ml_2, sl_2, 200))

#count number of p-values < .05 (when we reject H0)
rejections_count2 = sum(experiment_results2 < .05)

# calculate proportion of rejections to get probablity of type I error
p2 = rejections_count2 / length(experiment_results2)
p2

print(paste("We now see the proportion of p-values that lead to rejection of H0 is",p2,"."))
```

3) Repeat step 2 for the values: 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0

```{r, tidy = TRUE}
# We now update again the sigma and mu values as specified
sl_3 = c(1,1,1)

# Store mus in vector to send into list later
mus = c(0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0)

# Creat the different vectors of 3 mus, each vector with a different mu_1 from the variable mus
ml_3 = lapply(mus, function(x){c(x,0,0)})

# Run the function 100 times for each new mu list in mu_list3
p3 = replicate(100, lapply(ml_3, power_sim, sl_3, 200))

# Store the results of the nine experiments
results3a = p3[seq(1,900,by=9)]
results3b = p3[seq(2,900,by=9)]
results3c = p3[seq(3,900,by=9)]
results3d = p3[seq(4,900,by=9)]
results3e = p3[seq(5,900,by=9)]
results3f = p3[seq(6,900,by=9)]
results3g = p3[seq(7,900,by=9)]
results3h = p3[seq(8,900,by=9)]
results3i = p3[seq(9,900,by=9)]

#count number of p-values < .05 (when we reject H0)
rejections_count3a = sum(results3a < .05)
rejections_count3b = sum(results3b < .05)
rejections_count3c = sum(results3c < .05)
rejections_count3d = sum(results3d < .05)
rejections_count3e = sum(results3e < .05)
rejections_count3f = sum(results3f < .05)
rejections_count3g = sum(results3g < .05)
rejections_count3h = sum(results3h < .05)
rejections_count3i = sum(results3i < .05)

# Create data frame of proportion values from each test
prop = data.frame(NA)
prop$prop1 = rejections_count3a / length(results3a)
prop$prop2 = rejections_count3b / length(results3b)
prop$prop3 = rejections_count3c / length(results3c)
prop$prop4 = rejections_count3d / length(results3d)
prop$prop5 = rejections_count3e / length(results3e)
prop$prop6 = rejections_count3f / length(results3f)
prop$prop7 = rejections_count3g / length(results3g)
prop$prop8 = rejections_count3h / length(results3h)
prop$prop9 = rejections_count3i / length(results3i)
prop = subset(prop, select = -c(NA.))
prop
```

4) Plot the proportion of rejections.

```{r, tidy = TRUE}
# Stack the dataframe and then plot
prop_stacked = stack(prop)
plot(values~ind, data=prop_stacked, main = "Proportion levels of rejections for simulated mu's", xlab="Mu's", ylab="Proportions")
```

## BONUS
5) Set $\mu_1 = 1$, run ANOVA 100 times and compute the proportion of rejections for varying values of sample size. Instead of sample size=200 as in the previous problem, try size=5, 10, ..., 45, 50. Plot and explain results.

```{r, tidy = TRUE}
n = seq(from=5, to=50, by=5) # The sample sizes to run
powers = rep(NA, length(n)) # Empty object to collect simulation estimates
alpha = 0.05 # Standard alpha level
sims = 100
alpha = 0.05
experiments = 3
u = 0
s = 1

# Outer loop to vary the number of sample sizes tested
for (j in 1:length(n)){
  N = n[j]                              # Pick the jth value for N
  
  significant.experiments = rep(NA, sims)         # Empty object to count significant experiments
  
  # Conduct experiments "sims" times over for each N
  for (i in 1:sims){
    norm_list =  replicate(experiments, rnorm(n, u, s), simplify=FALSE) # control potential outcome
    names(norm_list) = paste0("group", 1:length(norm_list))
    # setting first element to 1    
    norm_list = lapply(norm_list, function(x) {x[1] <- 0; x})
    #run the ANOVA test
    norm_list = stack(norm_list)
    test = aov(values~ind, data=norm_list)
    p.value = as.numeric(summary(test)[[1]][["Pr(>F)"]][[1]])  # Extract p-values
    significant.experiments[i] = (p.value <= alpha) # Determine significance according to p <= 0.05
  }
  
  powers[j] = mean(significant.experiments)       # store average success rate (power) for each N
}
plot(n, powers, main = "Proportion levels of rejections for simulated sample sizes", xlab="Sample Sizes", ylab="Proportions")

print("In general, we know that increasing sample size should lead to increasing power. However, as the sample size is still relatively small in this simulation, there is a lot of randomness in the power of the simulated tests and corresponding sample sizes.")
```
