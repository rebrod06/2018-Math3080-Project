---
title: "Math Project"
author: "Rebecca Rodriguez, Erik Daenitz, Nick Hickman, Seoyeon Yang"
date: "April 2, 2018"
output: html_document
---


## Step 1: Perform paired t-test tests for all monthly means
- start at t = 2 (i.e. Year 0, Month 2)
- calc f stat for each test

## Step 2: Take max of all F-stats


## Step 3: Data prep
Get that shit

```{r, tidy = TRUE}
## Stream data into dataframe
treasuryRates = read.csv("./FED-SVENPY.csv")

## Subset dataframe to only include 10 year rates
treasury10Y = subset(treasuryRates, select=c(Date,SVENPY10))
treasury10Y = treasury10Y[complete.cases(treasury10Y), ]

# Plot for fun
plot(treasury10Y)

```

## Step 3a: Create Lambda Distribution from Monte Carlo methods
1) Monte Carlo simulation
- sample size n=1000
- simulate 1000 times
- for each simulation, grab max 
- with vector of 1000 maxes, use quantile function to calc critical-values

```{r, tidy = TRUE}
set.seed(1000) # set seed to ensure replicable results

n = 10000 # The number of standard normal datasets to be tested
sims = 50000 # The number of simulations to replicate, also the length of discrete values in our Lambda Distribution
mu = 0 # The true expected mean value of our normal distribution
s = 1 # The true variance of our normal distribution

## A Monte Carlo Simulation Function to generate our Lambda Distribution ##
lambdaSimA = function(sims,n,mu,s) {
  l = abs(c(replicate(sims,(max(rnorm(n,mu,s)))),replicate(sims,(min(rnorm(n,mu,s))))))
  return(l)
}

## A Monte Carlo Simulation Function to generate our Lambda Distribution ##
lambdaSimB = function(sims,n,mu,s) {
  l = replicate(sims,(max(abs(rnorm(n,mu,s)))))
  return(l)
}

## Run the function to generate the Lambda Distribution ##
lambdaDist = lambdaSim(sims,n,mu,s)

lambdaDistB = lambdaSimB(sims,n,mu,s)

## Generate CDF of our Lambda Distribution later use to generate p-values at various critical values
lambdaCDF = ecdf(lambdaDist)

lambdaCDFb = ecdf(lambdaDistB)

# Create LambdaPVal function to create P-values from our underlyinf Lambda Distribution
lambdaPVal = function (x){
  return(1-lambdaCDF(x))
} 

## Return appropriate critical values of our Lambda Distribution to later test our F-Statistic against  
lambdaQTSa = quantile(lambdaDist, probs = c(0.90, 0.95, 0.975, 0.99, 0.999), na.rm = FALSE, names = FALSE, type = 1)

lambdaQTSb = quantile(lambdaDistB, probs = c(0.90, 0.95, 0.975, 0.99, 0.999), na.rm = FALSE, names = FALSE, type = 1)

## Visualization of our friendly Lambda PDF and CDF
par(mfrow=c(2,2))
hist(lambdaDist)
plot(density(lambdaDist))
plot(lambdaCDF)

plot(density(lambdaDistB))
plot(lambdaCDFb)

```

## Step 3b: Create Lambda Distribution from resampling underlying Treasury data

```{r, tidy = TRUE}

## A Resampling Simulation Function to generate our Lambda Distribution ##
lambdaResample = function(sims,x) {
  l = replicate(sims,(sample(x, size=1, replace=FALSE)))
  return(l)
}

## Run the function to generate the Lambda Distribution ##
lambdaDist2 = lambdaResample(sims,treasury10Y$SVENPY10)

## Generate CDF of our Lambda Distribution later use to generate p-values at various critical values
lambdaCDF2 = ecdf(lambdaDist2)

# Create LambdaPVal function to create P-values from our underlyinf Lambda Distribution
lambdaPVal2 = function (x){
  return(1-lambdaCDF2(x))
} 

## Return appropriate critical values of our Lambda Distribution to later test our F-Statistic against  
lambdaQTS2 = quantile(lambdaDist2, probs = c(0.90, 0.95, 0.975, 0.99, 0.999), na.rm = FALSE, names = FALSE, type = 1)

## Visualization of our friendly Lambda PDF and CDF
par(mfrow=c(2,2))
hist(lambdaDist2)
plot(density(lambdaDist2))
plot(lambdaCDF2)

```



## Step 4: Compare test stats to critical values
- when test stat > critical val at sig level, reject H0 (i.e. calc p-val)
- rejection point --> change point





```{r tidy=TRUE}




```

